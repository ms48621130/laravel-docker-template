一覧画面の表示機能の作成

流れについては以下画像参照
https://res.cloudinary.com/gizumo-inc/image/upload/v1713129945/curriculums/Laravel%20Lesson/App/index_mvc.png

①一覧画面のURI(URL)の設定
PHP Appレッスンでは、直前のURIごとに実行する処理を変更する関数を定義していたが、
Laravelでは、URI(URL)とHTTPメソッドの組み合わせで実行する処理を変更することができる。

URI(URL)とHTTPメソッドの組み合わせで実行する処理を指定することをルート定義と呼ぶ。
ルート定義は、routes/web.phpに記述する必要がある。

routes/web.phpに以下を記述

Route::get('/todo', function () {
    echo 'Hello World!';
});

Route::get()はHTTPメソッドのGETを示しており、getメソッドの第一引数がURIを示している。
第二引数にそのURI(URL)とHTTPメソッドの組み合わせで実行したい処理を記述することでルートを定義することができる。


②一覧画面を表示
todoにアクセスした際に実行したい処理をroutes/web.phpに記載したが、
実行したい処理はControllerに移した方が保守性の観点から望ましい。

Controllerに処理を移すには、Route::get()の第二引数に対象のControllerとそのメソッドを指定する必要がある。
今回はTodoControllerのindexメソッドに処理を移譲する。

# appコンテナ内に以下コマンド
php artisan make:controller TodoController

routes/web.phpの記述を以下に変更
Route::get('/todo', 'TodoController@index');

TodoController.phpに処理内容を記述

一覧画面であるresources/views/todo/index.blade.phpを作成し、中身を記述

TodoController.phpの記述を変更
view関数を用いることで、画面として表示したいHTMLを指定することができる。
view関数の引数には、表示させたいBladeファイルを指定する必要があり、「resources/views/から対象の*.blade.phpまでの相対パスを.区切りで指定」する。


③DBに登録されているデータを取得する
Laravelでは、ORM (Object-Relational Mapping) の一つであるEloquentを用いることでDBの操作を行うことができる。
ORMとは、プログラミング言語のClassとデータベースのテーブルをマッピング（関連付け）することでSQLを直接操作することなく
データベースとマッピングされたClassのメソッドを用いることでDBとやり取りを行うことができる。
Laravelでは、データベースのテーブルとマッピングするClassがModelに当たる。

ModelのClassを作成し、データベースのテーブルとマッピングをする。
# appコンテナ内で以下コマンド
php artisan make:model Todo

app配下に作成されたTodoModelをデータベースのtodosテーブルとマッピングする。
app/Todo.phpに以下記述追加
protected $table = 'todos';
Modelを介することでSQL文を組み立てることなくtodosテーブルを操作することができるようになる。

TodoControllerでTodoModelを使えるようにするために、インスタンス化を行う。
app/Http/Controllers/TodoController.phpに以下記述追加
use App\Todo;
$todo = new Todo();

todosテーブルのレコードを全件取得するための実装。allメソッドを追加するだけで、全件取得することができる。
app/Http/Controllers/TodoController.phpに以下記述追加
$todos = $todo->all();
PHPはvar_dumpを使用することでデバッグを行うが、Laravelでは、Laravel固有のdd()を使用することでデバッグを行う。
ddによって、allメソッドの返り値がIlluminate\Database\Eloquent\Collectionクラスのインスタンスであることがわかる。
CollectionインスタンスはLaravelで用意されているクラスで配列操作に特化したクラスになる。
下記画像参照
https://res.cloudinary.com/gizumo-inc/image/upload/v1621913140/curriculums/Laravel%20Lesson/App/orm.png


④取得したデータを画面に渡す
todosテーブルのレコード情報を全て取得しただけでは画面に表示はされない。取得したデータをHTMLファイルに渡す必要がある。
Laravelでは、Controllerから、HTMLを表すbladeファイルへデータを渡すためにview関数を利用する。
view関数は画面に表示したいbladeファイルを第一引数で指定し、第二引数に渡したいデータを連想配列の形で渡すことができる。
view関数の第二引数の連想配列は、[blade内での変数名 => 代入したい値]を意味する。
実際にbladeファイルデータが渡っているか確認するためにbladeファイルでデバッグする。@dd()を使用する。
view関数を用いることでControllerからbladeファイルへデータを渡すことができる。


⑤画面上にデータを表示する
Controllerからbladeファイルへ渡したデータを画面上に表示する処理を実装する。
bladeファイルとはテンプレートエンジンの一つで、HTMLに比べて簡単に様々な機能を実施することができる。
resources/views/todo/index.blade.phpを修正
bladeにおいて、@はディレクティブと呼ばれ一般的なPHPの制御構文の便利な短縮記述方法を提供してくれる。
@foreachディレクティブはその見た目通りforeachを簡略化して表現してくれたもの
$todosには、Controllerにて取得したCollectionインスタンスが代入されている。
なぜインスタンスをforeachに？と思った方もいるやもしれないが、
先にも述べた通り「配列にできてCollectionにできないことはない」ので、問題ない。
foreachを使うことにより、Collectionインスタンスに格納されているTodoインスタンスを一つずつ$todoとして取り出している。
bladeでは、PHPを記述する際に{{ }}を用いる。この波括弧で囲うことで、その部分がPHPの処理として認識される。
$todo->contentはただのPHPの処理でしたので{{ }}が必要。
$todo->contentはtodosテーブルのレコードのcontentカラムを取得している。
このようにモデルクラスのインスタンスからは、$model->カラム名という記述で対応するレコードのカラム値を取得できる。
これとは別に{!! !!}という記法もあり、使い方は{{ }}と同じ。


⑥新規作成画面の表示
resources/views/todo/index.blade.phpに「ToDoを追加」ボタンを表示するコードを追加。

ボタンを押下した際にリクエストするルートを定義。
routes/web.phpに以下コードを追加
Route::get('/todo/create', 'TodoController@create');

resources/views/todo/create.blade.phpを作成

作成したBladeをview()を使用してControllerから実行しHTMLを生成。
app/Http/Controllers/TodoController.phpを以下コードに修正
return view('todo.create');


⑦Route・Viewのリファクタリング
新規作成画面へ遷移するボタンのhref属性にURLを直接記述しているが、以下2つの懸念点がある
・直接URLを記述するため可読性が低い
・URLに変更があった場合に関連する全ての記述を修正する必要があり保守性が低い
この問題を解決するために名前付きルートという機能がLaravelに用意されている。

まずはルートの定義に->name('ルート名')を記述して名前付きルートを定義する。
routes/web.phpを修正
Route::get('/todo/create', 'TodoController@create')->name('todo.create');

次にroute('ルート名')とすることで、ルート名からそのルートで設定したURLを生成することができる。
route('todo.create') を実行した時の返り値は http://localhost:8080/todo/create という文字列になる。
route()はview()などと同じLaravelでのみ使用できるヘルパ関数と呼ばれる関数の一種。
resources/views/todo/index.blade.phpを修正
<a class="btn btn-success" href="{{ route('todo.create') }}">ToDoを追加</a>

記述したら一覧画面に遷移し「ToDoを追加」ボタンの要素をデベロッパーツールで確認すると、
<a class="btn btn-success" href="http://localhost:8080/todo/create">ToDoを追加</a>と表示される
こうすることで、Blade内のURLの記述が簡潔になり可読性が向上する。
また、URLに変更がある場合でも、ルート名さえ変わらなければ修正箇所はweb.phpのみで済むため、保守性も向上する。


Bladeの分割と継承について
一覧画面と新規作成画面のBladeには、同じ記述が複数回登場している。
もし修正が必要な場合は全てのファイルの同じ記述を変更する必要があり、保守性が低い状態になってしまっている。
この問題を解決するために、Bladeの分割と継承を行う。これにより、共通の部分を別ファイルにまとめ、再利用可能にする。

共通部分を別Bladeに分割
共通部分を記述した以下のBladeファイルを新規作成
resources/views/layouts/base.blade.php

分割したBladeを継承
次に、一覧画面と新規作成画面の子となるBladeの共通部分を削除・追記
resources/views/todo/index.blade.php
resources/views/todo/create.blade.php

@extends('layouts.base')の記述で、継承する親Bladeを指定。
引数はresources/views/以降のパスを.区切りで指定し、拡張子は省略できる。
継承先の子Bladeの@section('content') ~ @endsectionで囲われた部分を、親Bladeの@yield('content')の部分に挿入している。
引数に同じ文字列'content'を指定することで、@section()と@yield()を紐づけている。
こうすることで、複数のBladeを組み合わせて1枚のHTMLを生成することが可能になる。
重複するコードを共通化して再利用できるようになるため、保守性が向上する。


⑧DBにデータを保存
ToDoの新規作成処理の実装の流れは以下4つ。

1.新規作成機能のルートの設定
ォームが送信された時にリクエストする、新規作成処理のルートを設定。
ToDoを新規作成するルートのため、HTTPメソッドはPOSTになる。
routes/web.phpに以下を追記
Route::post('/todo', 'TodoController@store')->name('todo.store');

定義したルートに対応するControllerのメソッドを定義。

作成ボタンを押した時に先ほど定義したルートが実行されるように、formタグのmethod属性とaction属性を記述
<form method="post" action="{{ route('todo.store') }}">

CSRF対策
作成ボタンを押すとdd()の結果ではなく以下のエラー画面が表示される。
419 Page Expired
この画面が表示されるのは、フォームを送信した際にCSRF対策のトークンが送信されておらず、無効なページと判断されているため。
Laravelではフォーム内に@csrfを追記するだけでCSRF対策が完了する。
新規作成画面でデベロッパーツールを使用して、@csrfが挿入されている箇所を確認すると
以下のように、CSRF対策のためのトークンが含まれたinputタグが生成されているのを確認できる。
<input type="hidden" name="_token" value="LZbo3MlrlFzHjmYHYiKw1Q9rxSpFvfB9LYZMWhPE">
この状態でフォームを送信することで、CSRF対策のトークンも一緒に送信され、Laravel側でトークンの検証も自動的に行ってくれる。


2.フォームから送信された値の取得
フォームから送信されたToDoの内容を取得する。
フォームから送信されたデータはIlluminate\Http\Requestクラスの->input()を使用することで取得できる。
->input()の引数には値を取得したい入力欄のname属性を指定。
app/Http/Controllers/TodoController.phpに追記

storeメソッドの引数にRequest $requestと書くことで、$requestにRequestクラスのインスタンスを代入している。
Laravelでは、メソッドの引数の左側にクラス名を書くことで、インスタンス化が自動で行われ、これをメソッドインジェクションと呼ぶ。


3.データの新規登録
ControllerからModelを呼び出し、取得したデータを使ってデータベースに新しいToDoを登録する処理を実装する。
LaravelのModelを使用したデータの新規作成は、TodoController.phpで、以下のステップで行う。

・todosテーブルの1レコードを表すTodoクラスをインスタンス化
$todo = new Todo();
・Todoインスタンスのカラム名のプロパティに保存したい値を代入
$todo->content = $content;
・Todoインスタンスの->save()を実行してオブジェクトの状態をDBに保存するINSERT文を実行
$todo->save();
以下画像参照
https://res.cloudinary.com/gizumo-inc/image/upload/v1623138052/curriculums/Laravel%20Lesson/App/orm_insert.png

Modelをテーブルの1レコードに見立てることで、DBへの接続処理や複雑なSQLを記述することなく、直感的にDBを操作することができる。


4.一覧画面へのリダイレクト
一覧画面にリダイレクトする処理を実装
routes/web.phpを下記のように変更
Route::get('/todo', 'TodoController@index')->name('todo.index');

app/Http/Controllers/TodoController.phpにリダイレクト処理を追記
return redirect()->route('todo.index');


⑨一括代入（Mass Assignment）
今のstoreメソッドの実装だと、もし新規作成画面に入力する項目が増えた場合に、
コードの修正が必要かつ肥大化する懸念があるため、保守性が低い状態になってしまう。
項目の数だけ入力値の取得とTodoインスタンスへの代入のコードが増えてしまう。
大規模なアプリケーションの場合はコードがさらに長くなり、可読性も低下する。
これを回避するために、一括代入（Mass Assignment）を使ってリファクタリングが必要になる。

1. フォームから送信された値を一括で取得
Requestクラスの->all()を使用して、フォームから送信された値を個別ではなく一括で取得するように変更。
app/Http/Controllers/TodoController.phpを変更

記述後、新規作成画面で任意のToDoを入力し、作成ボタンを押下すると
->all()が入力された全ての値を以下の形式で返しているのが確認できる。

2. 取得した値をModelに一括で代入
連想配列で取得した値を->fill()を使用して、Todoインスタンスの各プロパティに一括で代入。
->fill()は$todo->{連想配列のkey} = {連想配列のvalue}を配列の全ての要素に対して行ってくれる。
app/Http/Controllers/TodoController.phpを変更

app/Todo.phpを変更

この処理を行うことで画面の入力項目が増減しても常に同じコードで登録処理が実現できるようになり保守性と可読性が向上する

一括代入の脆弱性と$fillableについて
app/Todo.phpに記述した$fillableというプロパティは名前の通り->fill()によってModelに代入可能なプロパティを記述する。
なぜこのような制限をかけるかというと、便利な一括代入には実は脆弱性があり、
対策をせずに使用すると悪意のあるユーザに攻撃されてしまう恐れがあるため。
->fill()を使用した一括代入を行う際は、入力された値を信用せずにModelに$fillableを適切に設定し、
意図しないカラムを更新されないように気をつける。


















































